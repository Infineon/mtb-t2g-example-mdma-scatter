/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "cyhal.h"
#include "cy_pdl.h"
#include "cybsp.h"
#include "cy_retarget_io.h"

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: printArrayToUART
 * Summary:
 *  Helper function to print all elements of an uint32_t array into UART. Since it uses the printf function,
 *  it has to be assured by the caller that this function works as intended (retarget-io initialized)
 * Parameters:
 *  ARRAY - Pointer to array to print
 *  NUM - Number of elements of ARRAY 
 *  ARRAY_NAME - Name of the array. Will be printed in the beginning
 * Return:
 *  none
 **********************************************************************************************************************
 */
static void printArrayToUART(const uint32_t* array, const uint32_t num, const char* arrayName)
{
    if (array == NULL || num <= 0 || arrayName == NULL)
    {
        return;
    }

    printf("Data of %s: {%#x", arrayName, (unsigned int) array[0]);
    for (uint32_t i = 1; i < num; ++i)
    {
        printf(", %#x", (unsigned int) array[i]);
    }
    printf("}\r\n");
}

/**********************************************************************************************************************
 * Function Name: main
 * Summary:
 *  This is the main function for CPU. It initializes the DMA transfer, waits until it is finished
 *  and verifies the results.
 * Parameters:
 *  none
 * Return:
 *  0 if no errors occur. Not relevant, since main will never return.
 **********************************************************************************************************************
 */
int main(void)
{
    #if defined (CY_DEVICE_SECURE)
        cyhal_wdt_t wdt_obj;

        /* Clear watchdog timer so that it doesn't trigger a reset */
        result = cyhal_wdt_init(&wdt_obj, cyhal_wdt_get_max_timeout_ms());
        CY_ASSERT(CY_RSLT_SUCCESS == result);
        cyhal_wdt_free(&wdt_obj);
    #endif

    /* Initialize the device and board peripherals */
    if (cybsp_init() != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Enable instruction and data cache. Invalidate before enabling them. */
    SCB_InvalidateDCache();
    SCB_EnableDCache();
    SCB_InvalidateICache();
    SCB_EnableICache();

    /* Enable global interrupts */
    __enable_irq();

    /* Initialize retarget-io to use the debug UART port */
    if (cy_retarget_io_init(CYBSP_DEBUG_UART_TX, CYBSP_DEBUG_UART_RX, CY_RETARGET_IO_BAUDRATE) != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Initialize the User LED to indicate successful transfer via DMA */
    if (cyhal_gpio_init(CYBSP_USER_LED, CYHAL_GPIO_DIR_OUTPUT, CYHAL_GPIO_DRIVE_STRONG,
                                                               CYBSP_LED_STATE_OFF) != CY_RSLT_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Variables for DMAC */
    /* Array to which the source data is getting copied to */
    uint32_t dst[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    /* Array to copy data from, given in the scatter format */
    uint32_t src[] = {
            (uint32_t) &dst[2], 0, (uint32_t) &dst[7], 1,
            (uint32_t) &dst[0], 2, (uint32_t) &dst[1], 3,
            (uint32_t) &dst[5], 4, (uint32_t) &dst[4], 5,
            (uint32_t) &dst[3], 6, (uint32_t) &dst[6], 7
    };
    /* Reference array of how the data should look like in dst. Will be verified */
    const uint32_t REFERENCE[] = { 2, 3, 0, 6, 5, 4, 7, 1 };

    /* \x1b[2J\x1b[;H - ANSI ESC sequence for clear screen */
    printf("\x1b[2J\x1b[;H");
    printf("--- M-DMA Scatter Transfer Example ---\r\n\r\n");
    printf("Address of src array: 0x%08lx\r\n", (uint32_t) src);
    printArrayToUART(src, sizeof(src) / sizeof(src[0]), "src");
    printf("Address of dst array: 0x%08lx\r\n", (uint32_t) dst);
    printArrayToUART(dst, sizeof(dst) / sizeof(dst[0]), "dst");

    /* Initialize descriptor. Halts application if it fails */
    if (Cy_DMAC_Descriptor_Init(&myDMA_Descriptor_0, &myDMA_Descriptor_0_config) != CY_DMAC_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* Set the source address of the descriptor. Destination is not necessary for scatter transfer */
    Cy_DMAC_Descriptor_SetSrcAddress(&myDMA_Descriptor_0, src);

    /* Initialize channel. Halts application if it fails */
    if (Cy_DMAC_Channel_Init(myDMA_HW, myDMA_CHANNEL, &myDMA_channelConfig) != CY_DMAC_SUCCESS)
    {
        CY_ASSERT(0);
    }

    /* If cache is enabled, we have to assure that the descriptor and source data are properly cleaned
     * from cache. If not done, data might not be coherent anymore and DMA transfer can produce
     * unexpected behavior.
     */
    SCB_CleanDCache_by_Addr(src, (int32_t) sizeof(src));
    SCB_CleanDCache_by_Addr(&myDMA_Descriptor_0, (int32_t) sizeof(myDMA_Descriptor_0));

    /* Set descriptor to channel and enable it */
    Cy_DMAC_Channel_SetDescriptor(myDMA_HW, myDMA_CHANNEL, &myDMA_Descriptor_0);
    Cy_DMAC_Channel_Enable(myDMA_HW, myDMA_CHANNEL);

    /* Enable the DMAC */
    Cy_DMAC_Enable(myDMA_HW);

    /* Trigger DMA transfer via software */
    printf("Start DMA transfer!\r\n");
    Cy_TrigMux_SwTrigger(TRIG_OUT_MUX_3_MDMA_TR_IN0, CY_TRIGGER_TWO_CYCLES);

    /* We poll until DMA is finished. Alternatively, we could have registered an interrupt
     * handler and wait until the interrupt occurs.
     */
    while ((Cy_DMAC_Channel_GetInterruptStatus(DMAC, myDMA_CHANNEL) & CY_DMAC_INTR_COMPLETION)
            != CY_DMAC_INTR_COMPLETION)
    {
    }
    
    /* DMA transfer is finished now. If cache is enabled, we should assure that the dst data
     * is invalidated. Otherwise we might read the old values and do not see the result of the
     * DMA transfer. If dst is smaller than one cache-line (32-byte) and not aligned, take care
     * to not invalidate data that's still needed (does not happen in this example).
     */
    SCB_InvalidateDCache_by_Addr(dst, (int32_t) sizeof(dst));

    printf("DMA transfer finished!\r\n");
    printArrayToUART(dst, sizeof(dst) / sizeof(dst[0]), "dst");

    /* Verify data against reference */
    if (memcmp((void*) dst, (void*) REFERENCE, sizeof(dst)) == 0)
    {
        /* Verification successful. Turn LED on */
        printf("Data was transferred correctly!\r\n");
        cyhal_gpio_write(CYBSP_USER_LED, CYBSP_LED_STATE_ON);
    }
    else
    {
        /* Verification failed. Something went wrong */
        printf("Data in dst array is not as expected. Something went wrong.\r\n");
    }

    for (;;)
    {
    }

    return 0;
}

/* [] END OF FILE */
